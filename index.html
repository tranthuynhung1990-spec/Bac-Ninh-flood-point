<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>APP Tr·ªØ n∆∞·ªõc ‚Äî Map + Raster + Chart</title>

  <!-- Leaflet (CDN) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- PapaParse (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <!-- Chart.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --sidebar-width: 360px; }
    html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; }
    .container { display:flex; height:100vh; }
    #sidebar {
      width:var(--sidebar-width);
      padding:16px;
      box-sizing:border-box;
      border-right:1px solid #ddd;
      background:#f8f9fb;
      overflow:auto;
    }
    #map { flex:1; }
    h2 { margin-top:0; }
    label { display:block; margin-top:10px; font-weight:600; }
    select, button { width:100%; padding:8px; margin-top:6px; border-radius:4px; box-sizing:border-box; }
    #results { margin-top:12px; padding:10px; background:#fff; border:1px solid #e0e0e0; border-radius:6px; }
    /* Bi·ªÉu ƒë·ªì */
    canvas { width:100% !important; max-height:300px !important; }
    .muted { color:#666; font-size:13px; margin-top:6px; }
    .note { font-size:13px; color:#333; margin-top:6px; }
    .debug { font-size:12px; color:#b00; margin-top:6px; }

    .sub-group label {
      font-weight: normal;
      font-size: 13px;
      color: #555;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="sidebar">
      <h2>X√°c ƒë·ªãnh gi·∫£i ph√°p cung c·∫•p n∆∞·ªõc ∆∞u ti√™n</h2>
      <label class="main-label">Ch·ªçn v·ªã tr√≠</label>

      <div class="sub-group">
        <label for="province">T·ªânh</label>
        <select id="province">
          <option value="">-- ƒêang t·∫£i t·ªânh --</option>
        </select>

        <label for="commune">X√£</label>
        <select id="commune">
          <option value="">-- Ch·ªçn x√£ --</option>
        </select>
      </div>
      
      <label for="scale">Quy m√¥</label>
      <select id="scale">
        <option value="">-- Ch·ªçn quy m√¥ --</option>
        <option value="nho">Quy m√¥ nh·ªè</option>
        <option value="vua">Quy m√¥ trung b√¨nh</option>
        <option value="to">Quy m√¥ l·ªõn</option>
      </select>

      <label for="purpose">M·ª•c ƒë√≠ch s·ª≠ d·ª•ng</label>
      <select id="purpose">
        <option value="">-- Ch·ªçn m·ª•c ƒë√≠ch --</option>
        <option value="nongnghiep">N√¥ng nghi·ªáp</option>
        <option value="nongnghiep_sinhhoat">N√¥ng nghi·ªáp + Sinh ho·∫°t</option>
      </select>

      <button id="calcBtn">T√≠nh to√°n</button>
      <button id="exportChartBtn">üìä Xu·∫•t bi·ªÉu ƒë·ªì </button>
      <button id="exportExcelBtn">üìà Xu·∫•t k·∫øt qu·∫£ </button>

      <div id="results">
        <div><strong>Chi ph√≠:</strong> <span id="cost">-</span></div>
        <div><strong>L·ª£i √≠ch (h√†ng nƒÉm):</strong> <span id="benefit">-</span></div>
      </div>
      <canvas id="priorityChart"></canvas>

      <div id="debugLog" class="debug"></div>
    </div>

    <div id="map"></div>
  </div>

<script>
/* ---------- C·∫§U H√åNH ---------- */
const rasterCandidates = [
  'data/Loss_All_TL_wgs84_0.png',
  'data/Loss_Coff_HT_wgs84_0.png',
  'data/Loss_All_TL.png',
  'data/Loss_Coff_HT.png'
];

const boundsByFilename = {
  'Loss_All_TL_wgs84_0.png': [[12.5688,107.9821],[14.6023,109.3545]],
  'Loss_Coff_HT_wgs84_0.png': [[12.5691,107.9821],[14.4750,109.3216]]
};

/* ---------- H·ªñ TR·ª¢ LOG ---------- */
function dbg(msg){
  console.log(msg);
  const el = document.getElementById('debugLog');
  if(el) el.textContent = msg;
}

/* ---------- KH·ªûI T·∫†O B·∫¢N ƒê·ªí ---------- */
const map = L.map('map', {zoomControl:true}).setView([13.8,108.5], 8);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

/* ---------- T√åM V√Ä ADD RASTER ---------- */
async function findAndAddRaster() {
  let chosenUrl = null;
  for (let url of rasterCandidates) {
    try {
      let resp = await fetch(url, {method:'HEAD'});
      if (resp.ok) { chosenUrl = url; break; }
    } catch(e){}
  }
  if(!chosenUrl) { dbg('Kh√¥ng t√¨m th·∫•y file raster'); return; }

  const filename = chosenUrl.split('/').pop();
  let imgBounds = boundsByFilename[filename] || [[12.0,106.5],[15.0,110.5]];

  const rasterLayer = L.imageOverlay(chosenUrl, imgBounds, {opacity:0.8}).addTo(map);
  map.fitBounds(imgBounds);
  return rasterLayer;
}

/* ---------- T·∫¢I CSV ---------- */
let communeToRow = {};    // commune -> array row (keeps original structure)
let communeCoords = {};   // commune -> {lat, lon} (if found)
let provinceSet = new Set();

function loadCSV() {
  Papa.parse("DS_Xa_LVS.csv", {
    download: true,
    skipEmptyLines: true,
    complete: function(results) {
      const rows = results.data;
      if(!rows || rows.length < 2) {
        dbg('CSV l·ªói ho·∫∑c thi·∫øu d·ªØ li·ªáu'); populateProvinces(['ƒê·∫Øk L·∫Øk','Gia Lai']); return;
      }

      // B·ªè d√≤ng ti√™u ƒë·ªÅ ƒë·∫ßu ti√™n (header)
      rows.shift();

      // detect header row (common keywords)
      const firstRow = rows[0].map(c => (c||'').toString().trim().toLowerCase());
      let startIndex = 1;
      let latIdx = -1, lonIdx = -1;
      const headerKeywords = ['tinh','t·ªânh','xa','x√£','province','commune'];
      const isHeader = firstRow.some(cell => headerKeywords.some(k => cell.includes(k)));
      if(!isHeader) {
        // no header -> treat all rows as data (startIndex = 0)
        startIndex = 0;
      } else {
        // find lat/lon columns if named
        for (let i=0;i<firstRow.length;i++){
          const h = firstRow[i];
          if(/lat|latitude|vƒ© ƒë·ªô|vido|vƒ©/.test(h)) latIdx = i;
          if(/lon|longitude|kinh ƒë·ªô|kinhdo|long/.test(h)) lonIdx = i;
        }
      }

      // build maps
      for(let i=startIndex; i<rows.length; i++){
        const r = rows[i].map(c => (c===undefined ? '' : c.toString().trim()));
        if(r.length < 2) continue;
        const prov = r[0] || '';
        const comm = r[1] || '';
        if(!comm) continue;

        communeToRow[comm] = r;
        if(prov) provinceSet.add(prov);

        // if lat/lon indices known, save coords
        if(latIdx !== -1 && lonIdx !== -1 && r[latIdx] && r[lonIdx]) {
          communeCoords[comm] = { lat: r[latIdx], lon: r[lonIdx] };
        } else {
          // fallback: try to find numeric pair that looks like lat/lon inside the row
          for (let j=0; j<r.length-1; j++) {
            const a = parseFloat(r[j].replace(',','.'));
            const b = parseFloat(r[j+1].replace(',','.'));
            if(!isNaN(a) && !isNaN(b)) {
              // vietnam approx: lat ~ 6..25, lon ~ 102..111
              if (a >= 6 && a <= 25 && b >= 102 && b <= 111) {
                communeCoords[comm] = { lat: a, lon: b }; break;
              }
              if (b >= 6 && b <= 25 && a >= 102 && a <= 111) {
                communeCoords[comm] = { lat: b, lon: a }; break;
              }
            }
          }
        }
      }

      populateProvinces(Array.from(provinceSet).sort());
      dbg('CSV loaded. x√£: ' + Object.keys(communeToRow).length + ', coords available: ' + Object.keys(communeCoords).length);
    },
    error: function(err) {
      dbg('L·ªói ƒë·ªçc CSV: ' + (err.message || err));
      populateProvinces(['ƒê·∫Øk L·∫Øk','Gia Lai']);
    }
  });
}

function populateProvinces(provArray) {
  const sel = document.getElementById('province');
  sel.innerHTML = '<option value="">--Ch·ªçn t·ªânh--</option>';
  provArray.forEach(p => {
    const o = document.createElement('option'); o.value = p; o.textContent = p;
    sel.appendChild(o);
  });
}

document.getElementById('province').addEventListener('change', function(){
  const prov = this.value;
  const commSel = document.getElementById('commune');
  commSel.innerHTML = '<option value="">--Ch·ªçn x√£--</option>';
  Object.keys(communeToRow).forEach(comm => {
    const row = communeToRow[comm];
    if(prov === '' || row[0] === prov) {
      const o = document.createElement('option'); o.value = comm; o.textContent = comm;
      commSel.appendChild(o);
    }
  });
});

/* ---------- CHART ---------- */
const chartCtx = document.getElementById('priorityChart').getContext('2d');
const priorityChart = new Chart(chartCtx, {
  type: 'bar',
  data: {
    labels: [],
    datasets: [{
      label: 'Ph∆∞∆°ng √°n l·ª±a ch·ªçn',
      data: [],
      backgroundColor: 'rgba(54,162,235,0.7)'
    }]
  },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      title: {
        display: true,
        text: (ctx) => {
          const province = document.getElementById('province').selectedOptions[0]?.text || '';
          const commune = document.getElementById('commune').selectedOptions[0]?.text || '';
          if (province && commune) {
            return `Ch·ªâ s·ªë ∆∞u ti√™n cho c√°c gi·∫£i ph√°p tr·ªØ n∆∞·ªõc t·∫°i v·ªã tr√≠ x√£ ${commune}, t·ªânh ${province}`;
          } else if (province) {
            return `Ch·ªâ s·ªë ∆∞u ti√™n cho c√°c gi·∫£i ph√°p tr·ªØ n∆∞·ªõc t·∫°i t·ªânh ${province}`;
          } else {
            return 'Ch·ªâ s·ªë ∆∞u ti√™n cho c√°c gi·∫£i ph√°p tr·ªØ n∆∞·ªõc';
          }
        }
      },
      legend: {
        labels: {
          generateLabels: function(chart) {
            const labels = Chart.defaults.plugins.legend.labels.generateLabels(chart);
            labels.forEach(label => { label.fillStyle = 'red'; });
            return labels;
          }
        }
      },
      tooltip: {
        enabled: false
      },
      datalabels: {
        display: true,
        color: 'black',
        anchor: 'end',
        align: 'start',
        font: { size: 10, weight: 'bold' },
        formatter: function(value) { return value.toLocaleString(); }
      }
    },
    scales: {
      y: { beginAtZero: true }
    }
  },
  plugins: [ChartDataLabels]
});

function getCostIndex(scale, purpose) {
  if(scale==='nho' && purpose==='nongnghiep') return 2;
  if(scale==='nho' && purpose==='nongnghiep_sinhhoat') return 3;
  if(scale==='vua' && purpose==='nongnghiep') return 4;
  if(scale==='vua' && purpose==='nongnghiep_sinhhoat') return 5;
  if(scale==='to'  && purpose==='nongnghiep') return 6;
  if(scale==='to'  && purpose==='nongnghiep_sinhhoat') return 7;
  return null;
}

function getHighlightIndex(scale, purpose) {
  if(scale==='nho' && purpose==='nongnghiep') return 0;
  if(scale==='nho' && purpose==='nongnghiep_sinhhoat') return 1;
  if(scale==='vua' && purpose==='nongnghiep') return 2;
  if(scale==='vua' && purpose==='nongnghiep_sinhhoat') return 3;
  if(scale==='to'  && purpose==='nongnghiep') return 4;
  if(scale==='to'  && purpose==='nongnghiep_sinhhoat') return 5;
  return -1;
}

/* ---------- S·ª∞ KI·ªÜN T√çNH TO√ÅN (1 handler duy nh·∫•t) ---------- */
document.getElementById('calcBtn').addEventListener('click', function(){
  const prov = document.getElementById('province').value;
  const comm = document.getElementById('commune').value;
  const scale = document.getElementById('scale').value;
  const purpose = document.getElementById('purpose').value;
  if(!prov || !comm || !scale || !purpose) { alert('Ch·ªçn ƒë·ªß th√¥ng tin'); return; }

  const row = communeToRow[comm];
  if(!row) { alert('Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu x√£ ƒë√£ ch·ªçn'); return; }

  const costIdx = getCostIndex(scale, purpose);
  const benefitIdx = costIdx + 6;

  const costVal = parseFloat((row[costIdx] || '').toString().replace(',','.')) || 0;
  const benefitVal = parseFloat((row[benefitIdx] || '').toString().replace(',','.')) || 0;

  document.getElementById('cost').textContent = isNaN(costVal)?'N/A':costVal.toLocaleString();
  document.getElementById('benefit').textContent = isNaN(benefitVal)?'N/A':benefitVal.toLocaleString();

  const priorityIndices = [14,15,16,17,18,19,20,21];
  const labels = ["NN nh·ªè","NN+SH nh·ªè","NN trung b√¨nh","NN+SH trung b√¨nh","NN l·ªõn","NN+SH l·ªõn","ƒê√†o ao","T∆∞·ªõi hi·ªáu qu·∫£"];
  const values = priorityIndices.map(i => {
    const v = (row[i] || '').toString().replace(',','.');
    return (v === '' || isNaN(parseFloat(v))) ? 0 : parseFloat(v);
  });

  const colors = labels.map(() => 'rgba(54,162,235,0.7)');
  const hiIndex = getHighlightIndex(scale, purpose);
  if(hiIndex >= 0) colors[hiIndex] = 'rgba(255,0,0,0.8)';

  priorityChart.data.labels = labels;
  priorityChart.data.datasets[0].data = values;
  priorityChart.data.datasets[0].backgroundColor = colors;

  // update title dynamically (some Chart.js versions need explicit update for function-title)
  if (priorityChart.options && priorityChart.options.plugins && priorityChart.options.plugins.title && typeof priorityChart.options.plugins.title.text === 'function') {
    priorityChart.options.plugins.title.text = priorityChart.options.plugins.title.text; // keep function
  }
  priorityChart.update();

  /* === Hi·ªán marker x√£ tr√™n b·∫£n ƒë·ªì === */
  let coords = null;
  if (communeCoords[comm]) {
    coords = [parseFloat(communeCoords[comm].lat), parseFloat(communeCoords[comm].lon)];
  } else {
    // fallback: try to find in row numeric lat/lon pair
    for (let j=0; j<row.length-1; j++) {
      const a = parseFloat((row[j]||'').toString().replace(',','.'));
      const b = parseFloat((row[j+1]||'').toString().replace(',','.'));
      if(!isNaN(a) && !isNaN(b)) {
        if (a >= 6 && a <= 25 && b >= 102 && b <= 111) { coords = [a,b]; break; }
        if (b >= 6 && b <= 25 && a >= 102 && a <= 111) { coords = [b,a]; break; }
      }
    }
  }

  if (coords) {
    if (window.selectedMarker) { map.removeLayer(window.selectedMarker); }
    window.selectedMarker = L.circleMarker(coords, {
      radius: 8,
      color: '#e63946',
      fillColor: '#e63946',
      fillOpacity: 0.9
    }).addTo(map);
    // set view (zoom level adjustable)
    map.setView(coords, 11);
    window.selectedMarker.bindTooltip(`X√£ ${comm}, ${prov}`, { permanent: true, direction: 'top' }).openTooltip();
  } else {
    dbg('Kh√¥ng t√¨m th·∫•y to·∫° ƒë·ªô cho x√£: ' + comm);
  }
});

/* ---------- INIT ---------- */
(async function init(){
  await findAndAddRaster();
  loadCSV();

  // Load GeoJSON (optional)
  fetch("data/Bariver_basin.geojson")
    .then(resp => resp.json())
    .then(data => {
      const basinLayer = L.geoJSON(data, {
        style: { color: "blue", weight: 2, fillColor: "lightblue", fillOpacity: 0.2 },
        onEachFeature: function (feature, layer) {
          if (feature.properties) {
            if (feature.properties.TenVung) {
              layer.bindPopup("<strong>" + feature.properties.TenVung + "</strong>");
              const center = layer.getBounds().getCenter();
              L.marker(center, {
                icon: L.divIcon({ className: 'label-class', html: feature.properties.TenVung, iconSize: [100, 20] })
              }).addTo(map);
            }
          }
        }
      }).addTo(map);
      map.fitBounds(basinLayer.getBounds());
    })
    .catch(err => dbg("Kh√¥ng load ƒë∆∞·ª£c GeoJSON: " + err));
})();

/* === Export Chart Image === */
document.getElementById('exportChartBtn').addEventListener('click', () => {
  const link = document.createElement('a');
  link.download = 'bieu_do_tru_nuoc.png';
  link.href = priorityChart.toBase64Image();
  link.click();
});

/* === Export Excel for all communes in selected province === */
document.getElementById('exportExcelBtn').addEventListener('click', () => {
  const province = document.getElementById('province').value;
  if (!province) { alert('Vui l√≤ng ch·ªçn t·ªânh tr∆∞·ªõc khi xu·∫•t Excel.'); return; }

  const rows = Object.entries(communeToRow)
    .filter(([_, r]) => r[0] === province)
    .map(([comm, r]) => ({
      "T·ªânh": r[0],
      "X√£": comm,
      "NN nh·ªè": parseFloat(r[14]) || 0,
      "NN+SH nh·ªè": parseFloat(r[15]) || 0,
      "NN TB": parseFloat(r[16]) || 0,
      "NN+SH TB": parseFloat(r[17]) || 0,
      "NN l·ªõn": parseFloat(r[18]) || 0,
      "NN+SH l·ªõn": parseFloat(r[19]) || 0,
      "ƒê√†o ao": parseFloat(r[20]) || 0,
      "T∆∞·ªõi hi·ªáu qu·∫£": parseFloat(r[21]) || 0
    }));

  if (rows.length === 0) { alert('Kh√¥ng c√≥ d·ªØ li·ªáu cho t·ªânh ƒë√£ ch·ªçn.'); return; }

  const ws = XLSX.utils.json_to_sheet(rows);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "Ket_qua");
  XLSX.writeFile(wb, `Ket_qua_${province}.xlsx`);
});
</script>
</body>
</html>
